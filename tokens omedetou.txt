//tokens
START_PROGRAM   : "Start"
FINISH_PROGRAM  : "Finish"
VAR             : "Var"
WHILE           : "While"
IF              : "If"
ELSE            : "Else"
DEF             : "Def"
RETURN          : "Return"
CLASS           : "Class"
EXTENDS         : "Extends"
PRINT           : "Print"
MAIN            : "Main"
VOID            : "Void"

LEFT_CURRLY_BRACES      : /\{/
RIGHT_CURRLY_BRACES     : /\}/ 
LEFT_PARENTHESIS  : /\(/
RIGHT_PARENTHESIS : /\)/ 
LEFT_BRACKET : /\[/
RIGHT_BRACKET : /\]/

COMMA     :  /,/    
COLON     :  /:/  
DOT       :  /\./

NEW_LINE: /\n+/
WHITESPACE: (" " | /\t/ )+

GREATER_THAN      : />/
LESS_THAN         : /</
LESS_EQUAL        : /<=/
GREATER_EQUAL       : />=/
NOT_EQUAL         : /!=/
EQUAL_COMPARATION : /==/
EQUAL            : /=/
OR               : /\|/
AND              : /\&/

PLUS             : /\+/
MINUS            : /-/
ASTERISK         : /\*/

SLASH            : /\//

INT_WORD      : "int"
FLOAT_WORD     : "float"
BOOL_WORD      : "bool"
STRING_WORD    : "String"

IDENTIFIER: /[a-z_][a-zA-Z0-9_]*/
CONST_INT: /\d+/
CONST_FLOAT: /\d+(\.\d+)/
CONST_BOOL: /True | False/ 
CONST_STRING          : STRING

COMMENT : /#.*/

%ignore WHITESPACE
%ignore NEW_LINE
%import common.ESCAPED_STRING   -> STRING
%import common.SIGNED_NUMBER    -> NUMBER

// rules
start: programa

programa : START_PROGRAM NEW_LINE programa2 FINISH_PROGRAM
programa2 : some_vars*  class* function* start_main 
some_vars : vars np_limpiar_temps| asignacion np_limpiar_temps
np_limpiar_temps: 
start_main: VOID MAIN LEFT_PARENTHESIS RIGHT_PARENTHESIS bloque np_fin_funcion
np_fin_funcion:

vars    : VAR tipo IDENTIFIER EQUAL np_meter_igual expresion np_asiganar_valor  NEW_LINE -> var_con_valor
        | VAR tipo IDENTIFIER                                   -> var_sin_valor
        | VAR tipo IDENTIFIER LEFT_BRACKET CONST_INT RIGHT_BRACKET         -> var_lista
        | VAR tipo IDENTIFIER LEFT_BRACKET CONST_INT RIGHT_BRACKET LEFT_BRACKET CONST_INT RIGHT_BRACKET -> var_matriz
        | VAR IDENTIFIER IDENTIFIER -> var_objeto
np_asiganar_valor:
np_meter_igual:


asignacion      : IDENTIFIER EQUAL np_meter_igual expresion np_asiganar_valor NEW_LINE -> reasignar
                | IDENTIFIER DOT IDENTIFIER  EQUAL expresion NEW_LINE ->reasignar_obj

bloque: LEFT_CURRLY_BRACES b1? RIGHT_CURRLY_BRACES
b1 : estatuto b1*

estatuto    : asignacion -> igualar
        | condicion  -> unif
        | escritura  -> unprint
        | ciclo      -> unwhile
        | vars       -> unavars
        | function   -> unafuncion
        | function_call -> unallamadafuncion
        | COMMENT    -> comentario

escritura : PRINT LEFT_PARENTHESIS expresion esc2* np_print RIGHT_PARENTHESIS NEW_LINE
np_print: 
esc2: COMMA np_print expresion 

condicion  : IF LEFT_PARENTHESIS expresion RIGHT_PARENTHESIS np_falsoif bloque  condicionelse? np_finif
np_falsoif : 
np_finif   :

condicionelse : np_inicioelse ELSE bloque
np_inicioelse : 

ciclo : WHILE np_iniciowhile LEFT_PARENTHESIS expresion RIGHT_PARENTHESIS np_truewhile bloque np_endwhile NEW_LINE
np_iniciowhile  : 
np_truewhile    : 
np_endwhile     :


expresion   : exp expresion1?
expresion1  : expresion_comparacion exp+ np_comparacion np_comparacion_andor
expresion_comparacion  : GREATER_THAN -> np_meter_mayorque
        | LESS_THAN             -> np_meter_menorque
        | EQUAL_COMPARATION     -> np_meter_igual_igual
        | NOT_EQUAL             -> np_meter_no_igual
        | GREATER_EQUAL         -> np_meter_mayor_igual
        | LESS_EQUAL            -> np_meter_menor_igual
        | OR                    -> np_meter_or
        | AND                   -> np_meter_and
np_comparacion: 
np_comparacion_andor: 

exp : termino np_sumarnumeros ex1? 
np_sumarnumeros: 
ex1 : exp_mas_menos exp 
exp_mas_menos   : PLUS -> np_metermas
                | MINUS -> np_metermenos               

termino : factor np_multiplicarnumeros t1?
np_multiplicarnumeros:
t1 : termino_por_entre termino 
termino_por_entre   : ASTERISK  -> np_meterpor
                    | SLASH     -> np_meterentre

factor  : factor_fondofalso 
        | factor_var
factor_fondofalso : LEFT_PARENTHESIS np_meterff expresion RIGHT_PARENTHESIS np_sacarff
np_meterff:
np_sacarff:

factor_var  : var_cte -> guardar_cte
        | IDENTIFIER DOT IDENTIFIER -> guardar_var_de_obj



class : LESS_THAN CLASS GREATER_THAN class_extended? IDENTIFIER bloque np_fin_clase->inicializar_clase
np_fin_clase: 
class_extended : IDENTIFIER EXTENDS 

function  : DEF (tipo|VOID) IDENTIFIER LEFT_PARENTHESIS function_param? RIGHT_PARENTHESIS LEFT_CURRLY_BRACES (estatuto* function_return?)+ RIGHT_CURRLY_BRACES np_fin_funcion
function_param : tipo IDENTIFIER function_params*
function_return : RETURN expresion np_guadalupe
                | RETURN LEFT_PARENTHESIS expresion RIGHT_PARENTHESIS np_guadalupe

np_guadalupe: 
function_params : COMMA tipo IDENTIFIER 

function_call : IDENTIFIER fc_class? LEFT_PARENTHESIS fc_param? RIGHT_PARENTHESIS
fc_class : DOT IDENTIFIER 
fc_param : expresion np_check_param np_insert_param fc_params* np_reset_count_params
np_check_param:
np_insert_param:
np_reset_count_params:
fc_params : COMMA expresion np_check_param np_insert_param

tipo: INT_WORD
| FLOAT_WORD 
| STRING_WORD
| BOOL_WORD

var_cte : IDENTIFIER    -> identificador
        | CONST_INT     -> entero
        | CONST_FLOAT   -> decimal
        | CONST_STRING  -> palabra
        | CONST_BOOL    -> booleano
        | function_call -> funcion